<p><img src="/assets/images/vue内部流程图.png" alt="image" /></p>

<ul>
  <li>1、初始化及挂载
```
  new Vue()  -&gt;调用_init()函数初始化，初始化（生命周期，事件，props，methods，data,computed,watch等）
  初始化之后会调用$mount挂载组件。如果是运行时编译，即不存在render function</li>
</ul>

<p>```</p>

<ul>
  <li>2、编译
    <blockquote>
      <p>编译分为parse,optimize,generate三个阶段,最终得到render function</p>
    </blockquote>
  </li>
  <li>
    <p>parse : 使用正则等方式解析template模板的指令，class,style等数据，形成AST</p>
  </li>
  <li>
    <p>optimize: 标记static静态节点，这样update时，patch会跳过这个节点</p>
  </li>
  <li>
    <p>generate: 将AST转换成render function 字符串的过程，会得到render的字符串以及staticRenderFns字符串</p>
  </li>
  <li>
    <p>3、响应式</p>
  </li>
  <li>init的时候会通过Object.defineProperty进行绑定，从而setter与getter能应对读取与赋值操作</li>
  <li>render function倍手机的时候，会读取所需对象的值，从而触发getter函数进行依赖收集。</li>
  <li>依赖收集： 将观察者Watcher对象存放到当前闭包中的订阅者dep的subs中</li>
  <li>修改对象的值，出发setter，setter会notify Dep中的每一个watcher，告知值改变，需要渲染视图。watcher会调用update来更新试图</li>
  <li>
    <p>update的时候会有patch过程与使用队列来异步更新的策略 (setter -&gt; watcher -&gt; update)</p>
  </li>
  <li>4、更新视图</li>
  <li>数据变化后，执行render function 可以得到新的VNode节点</li>
  <li>解析新的VNode节点，然后用innerHtml直接全部渲染，这会造成性能浪费，从而中间加入patch过程，只渲染差异部分</li>
</ul>

<blockquote>
  <p>备注：vue剖析笔记系列基于染陌的小册《剖析 Vue.js 内部运行机制》</p>
</blockquote>
