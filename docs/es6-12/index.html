<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>es6-12-Genarator函数 · 哈利呦</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;ul&gt;
&lt;li&gt;1、Generator是干嘛的&lt;/li&gt;
&lt;/ul&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="es6-12-Genarator函数 · 哈利呦"/><meta property="og:type" content="website"/><meta property="og:url" content="https://github.com/BiaoZhiWang/"/><meta property="og:description" content="&lt;ul&gt;
&lt;li&gt;1、Generator是干嘛的&lt;/li&gt;
&lt;/ul&gt;
"/><meta property="og:image" content="https://github.com/BiaoZhiWang/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://github.com/BiaoZhiWang/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://github.com/BiaoZhiWang/blog/atom.xml" title="哈利呦 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://github.com/BiaoZhiWang/blog/feed.xml" title="哈利呦 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="哈利呦"/><h2 class="headerTitleWithLogo">哈利呦</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/es6-01" target="_self">系列文章</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>ES6</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">JavaScript<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ES6</h4><ul><li class="navListItem"><a class="navItem" href="/docs/es6-01">es6-01-let与const注意点</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-02">es6-02-变量的解析赋值</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-03">es6-03-基本的数据类型扩展</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-04">es6-04-对象类型的扩展</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-05">es6-05-对象的扩展(补充)</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-06">es6-06-symbol</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-07">es6-07-set与map的数据结构</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-08">es6-08-proxy</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-09">es6-09-reflect</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-10">es6-10-Promise对象</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-11">es6-11-Interator与for-of</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/es6-12">es6-12-Genarator函数</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Angular2<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/ang-01">Angular2学习笔记-组件01</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-02">Angular2学习笔记-组件02</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-03">Angular2学习笔记-angular的变化监测</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-04">Angular2学习笔记-模板相关01</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-05">Angular2学习笔记-模板相关02</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-06">Angular2学习笔记-指令相关</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-07">Angular2学习笔记-依赖注入</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-08">Angular2学习笔记-angular服务</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Vue2.x<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/vue-01">vue剖析笔记01-全局运行机制</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-02">vue剖析笔记04-实现一个VNode节点</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-03">vue剖析笔记05-template模板是怎么被compile编译的</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-04">vue剖析笔记02-响应式系统</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-05">vue剖析笔记03-依赖收集追踪原理</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-06">vue中的nextTick的实现</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-07">vue+vuex+vueRouter原理思维导图</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-08">vue-ssr简析</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">React<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/react-01">renderProps模式</a></li><li class="navListItem"><a class="navItem" href="/docs/react-02">提供者模式</a></li><li class="navListItem"><a class="navItem" href="/docs/react-03">组合组件</a></li><li class="navListItem"><a class="navItem" href="/docs/react-04">高阶组件</a></li><li class="navListItem"><a class="navItem" href="/docs/react-05">diff算法的演化历史</a></li><li class="navListItem"><a class="navItem" href="/docs/react-06">reactV16.0源码解析</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">设计模式<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/design-01">JS常见设计模式-JS面向对象</a></li><li class="navListItem"><a class="navItem" href="/docs/design-02">JS常见设计模式-单例策略代理迭代器</a></li><li class="navListItem"><a class="navItem" href="/docs/design-03">JS常见设计模式-发布订阅命令组合模板享元职责中介者</a></li><li class="navListItem"><a class="navItem" href="/docs/design-04">常见设计模式-装饰者状态适配器</a></li><li class="navListItem"><a class="navItem" href="/docs/design-05">编程建议</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">数据结构与算法<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/math-01">链表</a></li><li class="navListItem"><a class="navItem" href="/docs/math-02">归并与排序</a></li><li class="navListItem"><a class="navItem" href="/docs/math-03">您需要的前端面试算法(上)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">前端工程<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">测试</h4><ul><li class="navListItem"><a class="navItem" href="/docs/test-01">jasmine测试断言</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">gitlab</h4><ul><li class="navListItem"><a class="navItem" href="/docs/gitlab-01">gitlab-ci与gitlab-runner</a></li><li class="navListItem"><a class="navItem" href="/docs/gitlab-02">webpack集成到gitlab CI</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">webpack</h4><ul><li class="navListItem"><a class="navItem" href="/docs/webpack-01">webpack总结</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">前端安全<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/safe-01">前端安全思维导图</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">浏览器相关<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/browser-01">浏览器相关思维导图</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">服务器与运维<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/server-01">关于docker</a></li><li class="navListItem"><a class="navItem" href="/docs/server-02">服务端与网络思维导图</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">es6-12-Genarator函数</h1></header><article><div><span><ul>
<li>1、Generator是干嘛的</li>
</ul>
<blockquote>
<p>异步编程解决方案。首先它是一个函数，结合yield，封装多种状态，已达到异步编程。</p>
</blockquote>
<ul>
<li>2、Generator的基本使用</li>
</ul>
<pre><code class="hljs">  <span class="hljs-number">1</span>、写法：<span class="hljs-function"><span class="hljs-keyword">function</span> 后+ *，然后函数内部<span class="hljs-title">yield</span>设置状态
  例:
      <span class="hljs-title">function</span>* <span class="hljs-title">heGenerator</span><span class="hljs-params">()</span></span>{
          <span class="hljs-built_in">yield</span> <span class="hljs-string">''</span>hello;
          <span class="hljs-built_in">yield</span> <span class="hljs-string">"world"</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-string">"ending"</span>;
      }
      
       let hW=heGenerator();//这里相当于产生一个遍历对象
       conso;e.<span class="hljs-built_in">log</span>(hw.<span class="hljs-built_in">next</span>()); //{value:<span class="hljs-string">'hello'</span>,done:<span class="hljs-literal">false</span>};
        conso;e.<span class="hljs-built_in">log</span>(hw.<span class="hljs-built_in">next</span>()); //{value:<span class="hljs-string">'world'</span>,done:<span class="hljs-literal">false</span>};
        conso;e.<span class="hljs-built_in">log</span>(hw.<span class="hljs-built_in">next</span>()); //{value:<span class="hljs-string">'ending'</span>,done:<span class="hljs-literal">true</span>};
   
   
   <span class="hljs-number">2</span>、遍历器对象<span class="hljs-built_in">next</span>的运行逻辑:
      a、函数运行时，遇到yeild表达式，就会停止执行后面代码，将<span class="hljs-built_in">yield</span>后面紧跟的值作为value，结合done属性值作为一个对象返回。
      b、一直<span class="hljs-built_in">next</span>，知道<span class="hljs-keyword">return</span>语句，如果没有，则知道代码段结束，返回的value是undefiend.
   
   <span class="hljs-number">3</span>、函数里的代码需要在生成遍历器对象调用<span class="hljs-built_in">next</span>才会执行。即使没有<span class="hljs-built_in">yield</span>
      例:
          <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">f</span><span class="hljs-params">()</span></span>{
              console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'f执行'</span>)
          }
          
          var generatot=f();
          setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
              generator.<span class="hljs-built_in">next</span>();
          },<span class="hljs-number">1000</span>)
          
    <span class="hljs-number">4</span>、使用细节
       a、yiled只能放在Generator函数,放在其它地方会报错。
       b、如果<span class="hljs-built_in">yield</span>与其他表达式混合，那么需要加一个括号，如果是函数参数或者位于赋值表达式的右边，则不需要添加
         例:
            <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">demo</span><span class="hljs-params">()</span></span>{
                foo(<span class="hljs-built_in">yield</span> <span class="hljs-string">'a'</span>,yiled <span class="hljs-string">'b'</span>);
                console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'hello'</span>+<span class="hljs-built_in">yield</span>);
            }
       c、注意一个<span class="hljs-built_in">yield</span>代表一个暂停，无论它是函数参数，还是什么。
          foo(yiled <span class="hljs-string">'a'</span>,<span class="hljs-built_in">yield</span> <span class="hljs-string">'b'</span>);暂停三次<span class="hljs-built_in">next</span>后，才会执行foo函数
          
</code></pre>
<ul>
<li>3、与Interator的巧妙关系</li>
</ul>
<pre><code class="hljs">   Generator函数是遍历器生成函数，因此吧Generator复制给对象的<span class="hljs-built_in">Symbol</span>.iterator属性，可以让该对象具有Iterator接口
    例: 
       <span class="hljs-keyword">var</span> myIterable={};
       myIterable[<span class="hljs-built_in">Symbol</span>.iterator]=<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>)</span>{
           <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
           <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
           <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
       };
       
       [...myInterable];<span class="hljs-comment">//[1,2,3]</span>
       
       Genertor函数返回一个遍历器对象，该对象也有<span class="hljs-built_in">Symbol</span>.iterator属性
       <span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{};
       <span class="hljs-keyword">var</span> g=gen();
       g[<span class="hljs-built_in">Symbol</span>.iterator]()===g;<span class="hljs-comment">//Symbol.iterator执行后返回自己</span>

</code></pre>
<ul>
<li>4、next方法的参数</li>
</ul>
<pre><code class="hljs">    <span class="hljs-keyword">yield</span>表达式本身是没有明确的返回值的（总返回undefined）。<span class="hljs-keyword">next</span>方法可以带一个参数，这个参数可以作为上一个<span class="hljs-keyword">yield</span>表达式的返回值。
    注意，是本次<span class="hljs-keyword">next</span>的参数值作为上次<span class="hljs-keyword">yield</span>的返回值。当<span class="hljs-keyword">yield</span>返回值参与具体运算时，那么<span class="hljs-keyword">next</span>参数就发挥作用。
    
    这样带来的重大意义：可以在函数运行的不同阶段，通过<span class="hljs-keyword">next</span>传参，来调整函数行为。
    例：
       function* foo(x){
           let y=<span class="hljs-number">2</span>*(<span class="hljs-keyword">yield</span> (x+<span class="hljs-number">1</span>));
           let z=<span class="hljs-keyword">yield</span>(y/<span class="hljs-number">3</span>);
           <span class="hljs-keyword">return</span>  (x+y+z);
       }
       
       var a=foo(<span class="hljs-number">5</span>);
       a.<span class="hljs-keyword">next</span>();<span class="hljs-regexp">//</span>{<span class="hljs-symbol">value:</span><span class="hljs-number">6</span>,<span class="hljs-symbol">done:</span><span class="hljs-literal">false</span>}
       a.<span class="hljs-keyword">next</span>();<span class="hljs-regexp">//</span>{<span class="hljs-symbol">value:</span>NaN,<span class="hljs-symbol">done:</span><span class="hljs-literal">false</span>}
       a.<span class="hljs-keyword">next</span>();<span class="hljs-regexp">//</span>{<span class="hljs-symbol">value:</span>NaN,<span class="hljs-symbol">done:</span><span class="hljs-literal">true</span>}
       
       var b=foo(<span class="hljs-number">5</span>);
       b.<span class="hljs-keyword">next</span>();<span class="hljs-regexp">//</span>{<span class="hljs-symbol">value:</span><span class="hljs-number">5</span>,<span class="hljs-symbol">done:</span><span class="hljs-literal">false</span>};
       b.<span class="hljs-keyword">next</span>(<span class="hljs-number">12</span>);<span class="hljs-regexp">//</span>{<span class="hljs-symbol">value:</span><span class="hljs-number">8</span>,<span class="hljs-symbol">done:</span><span class="hljs-literal">false</span>};
</code></pre>
<ul>
<li>5、与for ...of的关系</li>
</ul>
<pre><code class="hljs">    <span class="hljs-number">1</span>、<span class="hljs-keyword">for</span>...of可以自动遍历Generator对象,不需next方法
      <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
          <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
          <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
          <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
          <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;
      }
      
      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> foo()){
          <span class="hljs-built_in">console</span>.log(v);<span class="hljs-comment">// 1 2 3 </span>
      }
      注意，当检测到返回对象的done属性为<span class="hljs-literal">true</span>时，<span class="hljs-keyword">for</span>...of循环就会终止，不会返回该对象，所以上面的<span class="hljs-keyword">return</span>返回的值就不会返回。
      
    <span class="hljs-number">2</span>、写出可以用<span class="hljs-keyword">for</span>...of遍历所有对象的方法.
       例:
          <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">ObjectEntries</span>(<span class="hljs-params">obj</span>)</span>{
              <span class="hljs-keyword">let</span> proprKeys=<span class="hljs-built_in">Reflect</span>.ownKeys(obj;
              <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> propKey <span class="hljs-keyword">of</span> propKeys){
                  <span class="hljs-keyword">yield</span> [propkey,obj[propKey]];
              }
          }
          
          <span class="hljs-keyword">let</span> obj={<span class="hljs-attr">a</span>:<span class="hljs-string">'a'</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">'b'</span>};
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> ObjectEntrise(obj)){
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`$[key]:<span class="hljs-subst">${value}</span>`</span>);
          }
          
          也可以将这个方法加到对象的Symnol.iterator上
            <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">objectEntries</span>(<span class="hljs-params"></span>)</span>{
                <span class="hljs-keyword">let</span> propKeys=<span class="hljs-built_in">Reflect</span>.ownKeys(<span class="hljs-keyword">this</span>);
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> propKey <span class="hljs-keyword">of</span> propKeys ){
                <span class="hljs-keyword">yield</span> [propKey,<span class="hljs-keyword">this</span>[propKey]];
                }
            }
            <span class="hljs-built_in">Object</span>.prototype[<span class="hljs-built_in">Symbol</span>.iterator]=objectEntries;

            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [key,value] <span class="hljs-keyword">of</span> {<span class="hljs-attr">a</span>:<span class="hljs-string">"a"</span>,<span class="hljs-attr">b</span>:<span class="hljs-string">'b'</span>}){
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${key}</span>:<span class="hljs-subst">${value}</span>`</span>)
            }
            
    <span class="hljs-number">3</span>、扩展运算符（...），解构赋值，<span class="hljs-built_in">Array</span>.from方法内部迪奥弄，都是遍历器接口，都可以将
    Generator函数返回的Iterator对象作为参数。
       <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span>(<span class="hljs-params"></span>)</span>{
           <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
           yeild <span class="hljs-number">2</span>;
           <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
           <span class="hljs-keyword">yield</span>  <span class="hljs-number">4</span>;
       }
       
       [...numbers()];<span class="hljs-comment">//[1,2]</span>
       <span class="hljs-built_in">Array</span>.from(numbers());<span class="hljs-comment">//[1,2]</span>
       <span class="hljs-keyword">let</span> [x,y]=numbers();<span class="hljs-comment">//[1,2]</span>
       
</code></pre>
<ul>
<li>6、遍历器对象拥有的方法</li>
</ul>
<pre><code class="hljs">    <span class="hljs-number">1</span>、Generator.prototype.<span class="hljs-keyword">throw</span>() ,在函数体外抛出错误，Generator函数体内可以捕获
      例:
      <span class="hljs-keyword">let</span> g=<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-params">()</span></span>{
          <span class="hljs-keyword">try</span>{
              yeild;
          }<span class="hljs-keyword">catch</span>(e){
              console.log(<span class="hljs-string">'内部捕获'</span>,e);
          }
      }
      <span class="hljs-keyword">var</span> i=g();
      i.next();
      
      <span class="hljs-keyword">try</span>{
          i.<span class="hljs-keyword">throw</span>(<span class="hljs-string">'a'</span>);
          i.<span class="hljs-keyword">throw</span>(<span class="hljs-string">'b'</span>);
      }<span class="hljs-keyword">catch</span>(e){
          console.log(<span class="hljs-string">'外部获取'</span>,e);
      }
      第一次捕获是Generator函数内部的捕获，它捕获完了之后，第二次<span class="hljs-keyword">throw</span>被外部捕获。
      
      注意：<span class="hljs-keyword">throw</span>方法被捕获以后，会附带执行下一条<span class="hljs-keyword">yield</span>表达式
       当Generator执行过程中抛出错误，没有被内部捕获，就不会被执行下去。如果继续执行next方法，
       那么将返回{value:undefined,done:<span class="hljs-keyword">true</span>};,js引擎会认为这个Generator遍历已经结束.
      
    <span class="hljs-number">2</span>、Generator。prototype.<span class="hljs-keyword">return</span>()  返回指定值，并结束遍历。相当于主动提前结束遍历
      例:
        <span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span><span class="hljs-params">()</span></span>{
            <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
            <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
        }
        
        <span class="hljs-keyword">let</span> g=gen();
        g.next();<span class="hljs-comment">//{value:1,done:false}</span>
        g.<span class="hljs-keyword">return</span>(<span class="hljs-string">'a'</span>);<span class="hljs-comment">//{value:'a',done:true};</span>
        g.next();<span class="hljs-comment">//{value:undefined,done:true};</span>
        
      如果Generator函数内部有<span class="hljs-keyword">try</span>-finnaly代码块，那么<span class="hljs-keyword">return</span>党阀会推迟到<span class="hljs-keyword">finally</span>代码块执行完执行。
        <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span><span class="hljs-params">()</span></span>{
            <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
            <span class="hljs-keyword">try</span>{
                <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
                <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
            }<span class="hljs-keyword">finally</span>{
                <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;
            }
        }
        <span class="hljs-keyword">let</span> g=numbers();
        g.next();
        g.mext();
        g.<span class="hljs-keyword">return</span>(<span class="hljs-number">7</span>);<span class="hljs-comment">//{value:4,done:false};</span>
        g.next() <span class="hljs-comment">//{value:5,done:false}</span>
        g.next()<span class="hljs-comment">//{value:7.done:true}</span>
      
    
</code></pre>
<ul>
<li>7、yield* 表达式</li>
</ul>
<pre><code class="hljs">    <span class="hljs-number">1</span>、在Generator函数内部调用另一个Generator默认是没作用的。需要使用<span class="hljs-keyword">yield</span>*，将遍历器包含。
     例:
        <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
            <span class="hljs-keyword">yield</span> <span class="hljs-string">'b'</span>;
        }
        
        <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
            <span class="hljs-keyword">yield</span>* foo();
        }
        <span class="hljs-comment">//相当于</span>
        
        <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
            <span class="hljs-keyword">yield</span> <span class="hljs-string">'a'</span>;
            <span class="hljs-keyword">yield</span>  <span class="hljs-string">'b'</span>;
        }
        <span class="hljs-comment">//等同于</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>{
            <span class="hljs-keyword">yield</span> <span class="hljs-string">'x'</span>;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> v <span class="hljs-keyword">of</span> bar()){
                \<span class="hljs-keyword">yield</span> v;
            }
        
        }
        
        注意如果没有使用<span class="hljs-keyword">yield</span>*，那么后面返回的是一个Generator遍历器对象
        
        如果有<span class="hljs-keyword">return</span>语句的时候，则需要用
        <span class="hljs-keyword">var</span> value=<span class="hljs-keyword">yield</span>* iterator的形式获取<span class="hljs-keyword">return</span>语句的值。
        
        事实上，只要<span class="hljs-keyword">yield</span>*后面跟的是一个可有iterator接口的数据结构，那么就可以被<span class="hljs-keyword">yield</span>*遍历。
         例:
            <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{
                <span class="hljs-keyword">yield</span>* [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>];
            }
            gen.next();<span class="hljs-comment">//{value:'a',done:false}</span>
            
        <span class="hljs-keyword">yield</span>* 遍历取出嵌套数组的所有成员
        例: 
           <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">itemTree</span>(<span class="hljs-params">tree</span>)</span>{
               <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(tree)){
                   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;tree.length;i++){
                       <span class="hljs-keyword">yield</span>* iterTree(tree[i]);
                   }
               }<span class="hljs-keyword">else</span>{
                   <span class="hljs-keyword">yield</span> tree;
               }
           }
           
           consot tree=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>]];
           
           <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> x <span class="hljs-keyword">of</span> iterTree(tree)){
               <span class="hljs-built_in">console</span>.log(x);
           }
           
         
        <span class="hljs-keyword">yield</span>* 语句遍历完全二叉树
        例:
          <span class="hljs-comment">//二叉树的构造函数</span>
          <span class="hljs-comment">//三个参数分别是左树，当前节点，右树</span>
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Tree</span>(<span class="hljs-params">left,label,right</span>)</span>{
              <span class="hljs-keyword">this</span>.left=left;
              <span class="hljs-keyword">this</span>.label=label;
              <span class="hljs-keyword">this</span>.right=right;
          }
          
          <span class="hljs-comment">//中序遍历函数</span>
          <span class="hljs-comment">//返回一个遍历器，使用generator函数</span>
          <span class="hljs-comment">//函数体内采用递归算法，所以左树与右树需要使用yield*遍历</span>
          <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">inorder</span>(<span class="hljs-params">t</span>)</span>{
              <span class="hljs-keyword">if</span>(t){
                  <span class="hljs-keyword">yield</span>* inorder(t.left);
                  <span class="hljs-keyword">yield</span> t.label;
                  <span class="hljs-keyword">yield</span>* inorder(t.right);
              }
          }
          
          <span class="hljs-comment">//生成二叉树</span>
          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">make</span>(<span class="hljs-params">array</span>)</span>{
              <span class="hljs-comment">//判断是否是叶节点</span>
              <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.length==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tree(<span class="hljs-literal">null</span>.array[<span class="hljs-number">0</span>],<span class="hljs-literal">null</span>);
              <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tree(make(array[<span class="hljs-number">0</span>],array[<span class="hljs-number">1</span>],make(array[<span class="hljs-number">2</span>])));
          }
          <span class="hljs-keyword">let</span> tree=make([[[<span class="hljs-string">'a'</span>],<span class="hljs-string">'b'</span>,[<span class="hljs-string">'c'</span>],<span class="hljs-string">'d'</span>,[[<span class="hljs-string">'e'</span>],<span class="hljs-string">'f'</span>,[<span class="hljs-string">'g'</span>]]]]);
          <span class="hljs-comment">//遍历二叉树</span>
          <span class="hljs-keyword">var</span> result=[];
          <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> node <span class="hljs-keyword">of</span> inorder(tree)){
              result.push(node);
          }
          <span class="hljs-built_in">console</span>.log(result);
          
</code></pre>
<ul>
<li>8、作为对象属性的Gemerator函数</li>
</ul>
<pre><code class="hljs">    简写:
       <span class="hljs-keyword">let</span> obj={
           * myGen(){
               <span class="hljs-params">...</span>
           }
       }
</code></pre>
<ul>
<li>9、Generator函数的this</li>
</ul>
<pre><code class="hljs">  Generator函数总返回一个遍历器，该遍历器对象会集成Generator函数prototype对象的方法。
  当其prototype定义属性，那么生成的遍历器对象也可以使用该属性
  Generator函数不能直接与<span class="hljs-keyword">new</span>一起使用。
  
  结合Generator函数的prototype，<span class="hljs-keyword">new</span>出具有遍历器属性的对象.
  例:
    <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">gen</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">this</span>.a=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.b=<span class="hljs-number">2</span>;
        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">this</span>.c=<span class="hljs-number">3</span>;
    }
    
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> gen.call(gem.prototype);
    }
    
    <span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> F();
    f.next();<span class="hljs-comment">//{value:2,done:false};</span>
    f.next();<span class="hljs-comment">//{value:3,done:false};</span>
    f.next();<span class="hljs-comment">// {value:undefined,done:true};</span>
    
    f.a;<span class="hljs-comment">//1</span>
    f.b;<span class="hljs-comment">//2</span>
    f.c;<span class="hljs-comment">//3</span>
</code></pre>
<ul>
<li>10、Generator的作用</li>
</ul>
<pre><code class="hljs">   <span class="hljs-number">1</span>、实现状态机
     <span class="hljs-keyword">var</span> clock=<span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"></span>)</span>{
         <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>){
             <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'true'</span>);
             <span class="hljs-keyword">yield</span>;
             <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'false'</span>);
             <span class="hljs-keyword">yield</span>;
         }
     }
     
    <span class="hljs-number">2</span>、Generator与协程
     js是单线程语言，只能保持一个调用栈，引入协程后，每一个任务可以保持自己的调用栈。
     这样在抛出错误的时候，可以找到原始的调用栈。
     如果将Generator函数当做协程，可以将多个需要互相协作的任务协程Generator函数。
     他们之间通过<span class="hljs-keyword">yield</span>表达式交换控制权。
     
    <span class="hljs-number">3</span>、异步操作的同步化表达
       异步操作的后续操作可以放在<span class="hljs-keyword">yield</span>表达式下面，等调用next方法执行才执行。
       这样可以使用Generator函数来处理异步操作。
       
       例：
          <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">loadUi</span>(<span class="hljs-params"></span>)</span>{
              showLoadingScreen();
              <span class="hljs-keyword">yield</span> loadUiDataAsynchronously();
              hideLoadingScreen();
          }
          
          <span class="hljs-keyword">let</span> loader=loadUi();
          loader.next();<span class="hljs-comment">//加载UI，并异步加载数据</span>
          loader.next();<span class="hljs-comment">//隐藏UI</span>
          
        例: ajax操作
           <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>{
               <span class="hljs-keyword">let</span> result=<span class="hljs-keyword">yield</span> request(<span class="hljs-string">"http://aaa."</span>);
               <span class="hljs-keyword">let</span> resp=Json.parse(result);
               <span class="hljs-built_in">console</span>.log(resp.value);
           } 
           
           <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">url</span>)</span>{
               makeAjaxCall(url,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>)</span>{
                   it.next(response);
               })
           }
           
           <span class="hljs-keyword">let</span> ir=main();
           it.next();
          <span class="hljs-comment">//让ajax操作更自然。</span>
          
         例: 逐行读取文本文件
           <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">numbers</span>(<span class="hljs-params"></span>)</span>{
               <span class="hljs-keyword">let</span> file=<span class="hljs-keyword">new</span> fileReader(<span class="hljs-string">'number.text'</span>);
               <span class="hljs-keyword">try</span>{
                   <span class="hljs-keyword">while</span>(!file.eof){
                       <span class="hljs-keyword">yield</span> <span class="hljs-built_in">parseInt</span>(file.readLine()<span class="hljs-number">.10</span>);
                   }
               }<span class="hljs-keyword">finally</span>{
                   file.close();
               }
           }
           
    <span class="hljs-number">4</span>、控制流管理  ,让多步操作更加直观
      <span class="hljs-comment">//回调函数版</span>
      step1(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value1</span>)</span>{
          step2(value1,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value2</span>)</span>{
              step2(value2,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value3</span>)</span>{
                  step4(value3,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value4</span>)</span>{
                      ...
                  })
              })
          })
      })
      
      <span class="hljs-comment">//Promise版</span>
      <span class="hljs-built_in">Promise</span>.resolve(step1)
             .then(step2)
             .then(step3)
             .then(step4)
             .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value4</span>)</span>{
                 ...
             },<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>{
                 ...
             })
             .done();
             
      <span class="hljs-comment">//Generator函数版</span>
      <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">longRunningTask</span>(<span class="hljs-params">value1</span>)</span>{
          <span class="hljs-keyword">try</span>{
              <span class="hljs-keyword">let</span> value2=<span class="hljs-keyword">yield</span> step1(value1);
              <span class="hljs-keyword">let</span> value3=<span class="hljs-keyword">yield</span> step2(value2);
              <span class="hljs-keyword">let</span> value4=<span class="hljs-keyword">yield</span>.step3(value3);
              <span class="hljs-keyword">let</span> value5=<span class="hljs-keyword">yield</span> step4(value4);
          }<span class="hljs-keyword">catch</span>(e){
              ...
          }
      }
      
      scheduler(longRunningTask(initialValue));
      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scheduler</span>(<span class="hljs-params">task</span>)</span>{
          <span class="hljs-keyword">let</span> taskObj=task.next(task.value);
          <span class="hljs-keyword">if</span>(!taskObj.done){
              task.value=taskObj.value;
              scheduler(task);
          }
      }<span class="hljs-comment">//这里只适合同步操作。</span>
      
      <span class="hljs-keyword">for</span>...of本质上是一个<span class="hljs-keyword">while</span>循环
      
      <span class="hljs-number">5</span>、给对象部署Iretator接口
      
    
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/es6-11"><span class="arrow-prev">← </span><span>es6-11-Interator与for-of</span></a><a class="docs-next button" href="/docs/ang-01"><span>Angular2学习笔记-组件01</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"></nav></div></div></body></html>