<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>vue剖析笔记05-template模板是怎么被compile编译的 · 哈利呦</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;compile&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#compile&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;compile&lt;/h2&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="vue剖析笔记05-template模板是怎么被compile编译的 · 哈利呦"/><meta property="og:type" content="website"/><meta property="og:url" content="https://github.com/BiaoZhiWang/"/><meta property="og:description" content="&lt;h2&gt;&lt;a class=&quot;anchor&quot; aria-hidden=&quot;true&quot; id=&quot;compile&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#compile&quot; aria-hidden=&quot;true&quot; class=&quot;hash-link&quot;&gt;&lt;svg class=&quot;hash-link-icon&quot; aria-hidden=&quot;true&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;compile&lt;/h2&gt;
"/><meta property="og:image" content="https://github.com/BiaoZhiWang/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://github.com/BiaoZhiWang/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://github.com/BiaoZhiWang/blog/atom.xml" title="哈利呦 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://github.com/BiaoZhiWang/blog/feed.xml" title="哈利呦 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="哈利呦"/><h2 class="headerTitleWithLogo">哈利呦</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/es6-01" target="_self">系列文章</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a target="_self"></a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Vue</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">JS<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">ES6</h4><ul><li class="navListItem"><a class="navItem" href="/docs/es6-01">es6-01-let与const注意点</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-02">es6-02-变量的解析赋值</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-03">es6-03-基本的数据类型扩展</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-04">es6-04-对象类型的扩展</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-05">es6-05-对象的扩展(补充)</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-06">es6-06-symbol</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-07">es6-07-set与map的数据结构</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-08">es6-08-proxy</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-09">es6-09-reflect</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-10">es6-10-Promise对象</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-11">es6-11-Interator与for-of</a></li><li class="navListItem"><a class="navItem" href="/docs/es6-12">es6-12-Genarator函数</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Angular2<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/ang-01">Angular2学习笔记-组件01</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-02">Angular2学习笔记-组件02</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-03">Angular2学习笔记-angular的变化监测</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-04">Angular2学习笔记-模板相关01</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-05">Angular2学习笔记-模板相关02</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-06">Angular2学习笔记-指令相关</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-07">Angular2学习笔记-依赖注入</a></li><li class="navListItem"><a class="navItem" href="/docs/ang-08">Angular2学习笔记-angular服务</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Vue<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/vue-01">vue剖析笔记01-全局运行机制</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-02">vue剖析笔记04-实现一个VNode节点</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/vue-03">vue剖析笔记05-template模板是怎么被compile编译的</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-04">vue剖析笔记02-响应式系统</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-05">vue剖析笔记03-依赖收集追踪原理</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-06">vue中的nextTick的实现</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-07">vue+vuex+vueRouter原理思维导图</a></li><li class="navListItem"><a class="navItem" href="/docs/vue-08">vue-ssr简析</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">React<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/react-01">renderProps模式</a></li><li class="navListItem"><a class="navItem" href="/docs/react-02">提供者模式</a></li><li class="navListItem"><a class="navItem" href="/docs/react-03">组合组件</a></li><li class="navListItem"><a class="navItem" href="/docs/react-04">高阶组件</a></li><li class="navListItem"><a class="navItem" href="/docs/react-05">diff算法的演化历史</a></li><li class="navListItem"><a class="navItem" href="/docs/react-06">reactV16.0源码解析</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">设计模式<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/design-01">JS常见设计模式-JS面向对象</a></li><li class="navListItem"><a class="navItem" href="/docs/design-02">JS常见设计模式-单例策略代理迭代器</a></li><li class="navListItem"><a class="navItem" href="/docs/design-03">JS常见设计模式-发布订阅命令组合模板享元职责中介者</a></li><li class="navListItem"><a class="navItem" href="/docs/design-04">常见设计模式-装饰者状态适配器</a></li><li class="navListItem"><a class="navItem" href="/docs/design-05">编程建议</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">数据结构与算法<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/math-01">链表</a></li><li class="navListItem"><a class="navItem" href="/docs/math-02">归并与排序</a></li><li class="navListItem"><a class="navItem" href="/docs/math-03">您需要的前端面试算法(上)</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">前端工程<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">测试</h4><ul><li class="navListItem"><a class="navItem" href="/docs/test-01">jasmine测试断言</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">gitlab</h4><ul><li class="navListItem"><a class="navItem" href="/docs/gitlab-01">gitlab-ci与gitlab-runner</a></li><li class="navListItem"><a class="navItem" href="/docs/gitlab-02">webpack集成到gitlab CI</a></li></ul></div><div class="navGroup subNavGroup"><h4 class="navGroupSubcategoryTitle">webpack</h4><ul><li class="navListItem"><a class="navItem" href="/docs/webpack-01">webpack总结</a></li></ul></div></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">浏览器相关<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/browser-01">浏览器相关思维导图</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">服务器与运维<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/server-01">关于docker</a></li><li class="navListItem"><a class="navItem" href="/docs/server-02">服务端与网络思维导图</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">vue剖析笔记05-template模板是怎么被compile编译的</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="compile"></a><a href="#compile" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>compile</h2>
<blockquote>
<p>compile 编译分为parse, optimize, generate三个阶段</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="parse"></a><a href="#parse" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>parse</h2>
<blockquote>
<p>通过正则等方式将template模板进行字符串解析，得到指令，class,style等数据,形成AST(抽象语法树);</p>
</blockquote>
<blockquote>
<p>能够描述出标签的属性以及依赖关系</p>
</blockquote>
<pre><code class="hljs"> <span class="hljs-regexp">//</span>得到的AST示例
 {
     <span class="hljs-regexp">//</span>标签属性的map，记录标签上属性
     <span class="hljs-string">'attrsMap'</span> : {
         <span class="hljs-string">':class'</span>: <span class="hljs-string">'c'</span>,
         <span class="hljs-string">'class'</span>: <span class="hljs-string">'demo'</span>,
         <span class="hljs-string">'v-if'</span>: <span class="hljs-string">'isShow'</span>
     },
     <span class="hljs-regexp">//</span>解析得到的:class
     <span class="hljs-string">'classBinding'</span>: <span class="hljs-string">'c'</span>,
     <span class="hljs-regexp">//</span>标签数据行v-<span class="hljs-keyword">if</span>
     <span class="hljs-string">'if'</span>: <span class="hljs-string">'isShow'</span>,
     <span class="hljs-regexp">//</span>v-<span class="hljs-keyword">if</span> 的条件
     <span class="hljs-string">'ifCondition'</span>: [
         <span class="hljs-string">'exp'</span> : <span class="hljs-string">'isShow'</span>
     ],
     <span class="hljs-regexp">//</span>标签属性class
     <span class="hljs-string">'staticClass'</span>: <span class="hljs-string">'demo'</span>,
     <span class="hljs-regexp">//</span>标签的tag
     <span class="hljs-string">'tag'</span>:<span class="hljs-string">'div'</span>,
     <span class="hljs-regexp">//</span>子标签数组
     <span class="hljs-string">'children'</span>: [
         {
             <span class="hljs-string">'attrsMap'</span>: {
                 <span class="hljs-string">'v-for'</span>: <span class="hljs-string">'item in sz'</span>
             },
             <span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> 循环的参数
             <span class="hljs-string">'alias'</span>: <span class="hljs-string">'item'</span>,
             <span class="hljs-regexp">//</span><span class="hljs-keyword">for</span>循环的对象
             <span class="hljs-string">'for'</span>: <span class="hljs-string">'sz'</span>,
             <span class="hljs-regexp">//</span><span class="hljs-keyword">for</span> 循环是否已经被处理的标记位
             <span class="hljs-string">'forProcessed'</span>: true,
             <span class="hljs-string">'tag'</span>: <span class="hljs-string">'span'</span>,
             <span class="hljs-string">'children'</span>: [
                 {
                     <span class="hljs-regexp">//</span>表达式,_s是一个转字符串的函数
                     expression: <span class="hljs-string">'_s(item)'</span>,
                     <span class="hljs-string">'text'</span>: <span class="hljs-string">'{{item}}'</span>
                 }
             ]
         }
     ]
 }
</code></pre>
<ul>
<li>定义正则</li>
</ul>
<pre><code class="hljs">    <span class="hljs-keyword">const</span> ncname = <span class="hljs-string">'[a-zA-Z][\\w\\-\\.]*'</span>;
    <span class="hljs-keyword">const</span> singleAttrIndentifer = <span class="hljs-regexp">/([^\s"'&lt;&gt;/=]+)/</span>
    <span class="hljs-keyword">const</span> singleAttrAssign = <span class="hljs-regexp">/(?:=)/</span>
    <span class="hljs-keyword">const</span> singleAttrValues = [
        <span class="hljs-regexp">/"([^"]*)"+/</span>.source,
        <span class="hljs-regexp">/'([^'])'+/</span>.source,
        <span class="hljs-regexp">/([^\s"'=&lt;&gt;`]+)/</span>.source
    ]
    <span class="hljs-keyword">const</span> attribute = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(
        <span class="hljs-string">'^\\s*'</span> + singleAttrIdentifer.source +
        <span class="hljs-string">'(?;\\S*('</span>+ singleAttrAssign.source + <span class="hljs-string">')'</span> +
        <span class="hljs-string">'\\s*(?:'</span> + singleAttrValues.join(<span class="hljs-string">'|'</span>) + <span class="hljs-string">'))?'</span>
    )

    <span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">'((?:'</span> + ncname + <span class="hljs-string">'\\:)?'</span> + ncname + <span class="hljs-string">')'</span>
    <span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^&lt;'</span> + qnameCapture);
    <span class="hljs-keyword">const</span> startTagClose = <span class="hljs-regexp">/^\s*(\/?)&gt;/</span>

    <span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^&lt;\\/'</span> + qnameCapture + <span class="hljs-string">'[^&gt;]*&gt;'</span>)

    <span class="hljs-keyword">const</span> defaultTagRE = <span class="hljs-regexp">/\{\{((?:.|\n)+?)\}\}/g</span>

    <span class="hljs-keyword">const</span> forAliasRE = <span class="hljs-regexp">/(.*?)\s+(?:in|of)\s+(.*)/</span>
</code></pre>
<ul>
<li>advance</li>
</ul>
<blockquote>
<p>解析template采用循环进行字符串匹配的方式，每次匹配解析玩一段，就会将匹配掉的去掉。头部指针会指向接下来需要匹配的部分</p>
</blockquote>
<pre><code class="hljs">    function advance (<span class="hljs-built_in">n</span>) {
        <span class="hljs-built_in">index</span> += <span class="hljs-built_in">n</span>;
        html = html.subString(<span class="hljs-built_in">n</span>);
    }
</code></pre>
<ul>
<li>parseHTML</li>
</ul>
<blockquote>
<p>循环解析template字符串,使用正则匹配到标签头，标签尾以及文本的时候进行不同处理，直到整个template解析完毕</p>
</blockquote>
<pre><code class="hljs">    function <span class="hljs-built_in">parseHTML</span> () {
        <span class="hljs-keyword">while</span>(html) {
            <span class="hljs-keyword">let</span> textEnd = html.indexOf('&lt;');
            <span class="hljs-keyword">if</span> (textEnd ===<span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (html.match(endTag)) {
                    <span class="hljs-comment">//... process end tag</span>
                    <span class="hljs-keyword">continue</span>;
                }

                <span class="hljs-keyword">if</span> (html.match(startTagOpen)) {
                    <span class="hljs-comment">//...process start tag</span>
                    <span class="hljs-keyword">continue</span>
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-comment">//...process text</span>
                continueS
            }
        }
    }
</code></pre>
<ul>
<li>parseStartTag</li>
</ul>
<blockquote>
<p>解析起始标签</p>
</blockquote>
<pre><code class="hljs">    //以 <span class="hljs-string">"&lt;div :class="</span>c<span class="hljs-string">" class="</span>demo<span class="hljs-string">" v-if="</span>isShow<span class="hljs-string">"&gt;"</span>部分

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseStartTag</span> <span class="hljs-params">()</span></span> {
        //标签头部，得到tagname
        const start = html.<span class="hljs-built_in">match</span>(startTagOpen);
        <span class="hljs-keyword">if</span> (start) {
            const <span class="hljs-built_in">match</span> = {
                tagName: start[<span class="hljs-number">1</span>],
                attrs: [],
                start: index
            }
            advance(start[<span class="hljs-number">0</span>].length);

            let <span class="hljs-keyword">end</span>, attr
            //解析标签结束与标签内的属性
            <span class="hljs-keyword">while</span>( !(<span class="hljs-keyword">end</span> = html.<span class="hljs-built_in">match</span>(startTagClose)) &amp;&amp; (attr = html.<span class="hljs-built_in">match</span>(attribute))) {
                advance(attr[<span class="hljs-number">0</span>].length)
                <span class="hljs-built_in">match</span>.attrs.push({
                    name: attr[<span class="hljs-number">1</span>],
                    value: attr[<span class="hljs-number">3</span>]
                })
            }
            
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">end</span>) {
                <span class="hljs-built_in">match</span>.unarySlash = <span class="hljs-keyword">end</span>[<span class="hljs-number">1</span>];
                advance(<span class="hljs-keyword">end</span>[<span class="hljs-number">0</span>].length)
                <span class="hljs-built_in">match</span>.<span class="hljs-keyword">end</span> = index
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">match</span>
            }
        }
    }
</code></pre>
<ul>
<li>stack</li>
</ul>
<blockquote>
<p>维护一个stack栈来保存已经解析号的标签头，这样解析尾标签的时候可以得到层级关系以及父标签。
定义一个currentParent变量来存放当前标签父标签节点的引用，root变量指向根节点标签</p>
</blockquote>
<pre><code class="hljs">    <span class="hljs-comment">//在startTagOpen 的if逻辑加上额外处理</span>
    <span class="hljs-comment">//将startTagMatch 结果封装成element.这个会是最终的AST节点。 标签节点type为1</span>
    <span class="hljs-keyword">if</span> (html.<span class="hljs-keyword">match</span>( startTagOpen)) {
        const startTagMatch = parse<span class="hljs-constructor">StartTag()</span>;
        const element = {
            <span class="hljs-keyword">type</span>: <span class="hljs-number">1</span>,
            tag: startTagMatch.tagName,
            lowerCasedTag: startTagMatch.tagName.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>,
            attrsMap: make<span class="hljs-constructor">AttrsMap(<span class="hljs-params">startTagMatch</span>.<span class="hljs-params">attrs</span>)</span>,
            parent: currentParent,
            children: <span class="hljs-literal">[]</span>
        }
        <span class="hljs-comment">//让root指向根节点的引用</span>
        <span class="hljs-keyword">if</span> (!root) {
            root = element
        }
        <span class="hljs-comment">//将当前节点的element放入父节点的children中</span>
        <span class="hljs-keyword">if</span> (currentParent) {
            currentParent.children.push(elemnt)
        }
        <span class="hljs-comment">//将element压入栈</span>
        stack.push(element)
        currentParent = element
        continue
    }
    <span class="hljs-comment">//如果下一个解析到的还是头标签或者是文本的话，这个新解析的节点会是当前节点的子节点</span>
    <span class="hljs-comment">//如果尾标签，则会从栈中取出当前节点</span>
</code></pre>
<ul>
<li>parseEngTag</li>
</ul>
<blockquote>
<p>用来解析为标签，会从stack中取出最近的与自己标签名一直的元素，将currentParent指向该元素，同时将该元素前面的元素出栈
由于存在自闭合标签如<br />，没有完整闭合标签的情况，所有要找最近一个标签名同名的，而不是第一个出栈的元素</p>
</blockquote>
<pre><code class="hljs">    function parseEndTag (tagName) {
        let <span class="hljs-keyword">pos</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">pos</span> = stack.length - <span class="hljs-number">1</span>; <span class="hljs-keyword">pos</span> &gt;=<span class="hljs-number">0</span> ;<span class="hljs-keyword">pos</span>--) {
            <span class="hljs-keyword">if</span> (stack[<span class="hljs-keyword">pos</span>].lowerCasedTag === tagName.tolowerCase()) {
                <span class="hljs-keyword">break</span>;
            }
        }

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">pos</span> &gt;= <span class="hljs-number">0</span>) {
            stack.length = <span class="hljs-keyword">pos</span>;
            currentParent = stack[<span class="hljs-keyword">pos</span>];
        }
    }
</code></pre>
<ul>
<li>parseText</li>
</ul>
<blockquote>
<p>解析文本，解析文本需要分为普通文本以及表达式的文本</p>
</blockquote>
<ul>
<li>普通文本： 直接构建一个节点push进当前的currentParent的children即可</li>
<li>带表达式的文本; 需要parseText 来将表达式转化成代码</li>
</ul>
<pre><code class="hljs">   var <span class="hljs-built_in">text</span> = html.substring(<span class="hljs-number">0</span>, textEnd);
   advance(textEnd)
   let expression;
   <span class="hljs-keyword">if</span> (expression = parseText(<span class="hljs-built_in">text</span>)) {
       currentParent.children.push( {
           type: <span class="hljs-number">2</span>,
           <span class="hljs-built_in">text</span>,
           expression
       });
   } <span class="hljs-keyword">else</span> {
       currentParent.children.push({
           type: <span class="hljs-number">3</span>,
           <span class="hljs-built_in">text</span>
       })
   }
   <span class="hljs-keyword">continue</span>;

   <span class="hljs-comment">//获取表达式</span>
   <span class="hljs-comment">//tokens数组存放解析结果， defaultTagRE循环匹配该文本,如果是普通文本直接push进tokens,</span>
   <span class="hljs-comment">//如果是表达式，则会转化成'_s(${exp})'形式</span>
   function parseText ( <span class="hljs-built_in">text</span>) {
       <span class="hljs-keyword">if</span> (!defaultTagRE.test(<span class="hljs-built_in">text</span>)) <span class="hljs-keyword">return</span>;

       <span class="hljs-keyword">const</span> tokens = [];
       let lastIndex = defaultTagRE.lastIndex = <span class="hljs-number">0</span>;
       let <span class="hljs-built_in">match</span>, index;
       <span class="hljs-keyword">while</span>((<span class="hljs-built_in">match</span> = defaultTagRE.exec(<span class="hljs-built_in">text</span>))) {
           index = <span class="hljs-built_in">match</span>.index;

           <span class="hljs-keyword">if</span> (index &gt; lastIndex) {
               tokens.push(JSON.stringify(<span class="hljs-built_in">text</span>.slice(lastIndex, index)));
           }

           <span class="hljs-keyword">const</span> <span class="hljs-built_in">exp</span> = <span class="hljs-built_in">match</span>[<span class="hljs-number">1</span>].<span class="hljs-built_in">trim</span>()
           tokens.push(`_s(${<span class="hljs-built_in">exp</span>})`)
           lasIndex = index + <span class="hljs-built_in">match</span>[<span class="hljs-number">0</span>].length;
       }

       <span class="hljs-keyword">if</span> (lastIndex &lt; <span class="hljs-built_in">text</span>.legnth) {
           tokens.push(JSON.stringify(<span class="hljs-built_in">text</span>.slice(lastIndex)))
       }
       <span class="hljs-keyword">return</span> tokens.<span class="hljs-built_in">join</span>(<span class="hljs-string">'+'</span>)

   }

   <span class="hljs-comment">//例</span>
   &lt;div&gt;hello, {{name}}&lt;/div&gt;
   <span class="hljs-comment">// tokens</span>
   tokens = [<span class="hljs-string">'helloe'</span>, _s(name)]
   <span class="hljs-comment">//join返回表达式</span>
   <span class="hljs-string">'hello'</span>+ _s(name) 
</code></pre>
<ul>
<li>如何解析v-if, v-for这样的表达式的呢？ professIf与 professFor</li>
</ul>
<blockquote>
<p>只需要在解析头标签的内容加入这两个表达式的解析函数即可。</p>
</blockquote>
<pre><code class="hljs">   <span class="hljs-keyword">if</span> (html.<span class="hljs-keyword">match</span>(startTagOpen)) {
           const startTagMatch = parse<span class="hljs-constructor">StartTag()</span>;
           const element = {
               <span class="hljs-keyword">type</span>: <span class="hljs-number">1</span>,
               tag: startTagMatch.tagName,
               attrsList: startTagMatch.attrs,
               attrsMap: make<span class="hljs-constructor">AttrsMap(<span class="hljs-params">startTagMatch</span>.<span class="hljs-params">atts</span>)</span>,
               parent: currentParent,
               children:<span class="hljs-literal">[]</span>
           }

           process<span class="hljs-constructor">If(<span class="hljs-params">element</span>)</span>;
           process<span class="hljs-constructor">For(<span class="hljs-params">element</span>)</span>;

           <span class="hljs-keyword">if</span> (!root) {
               root = element;
           }
           <span class="hljs-keyword">if</span> (currentParent) {
               currentParent.children.push(element);
           }

           stack.push(element);
           currentParent = element;
           continue
       }
       <span class="hljs-comment">//从el的attrsMap属性或是attrslist属性取出name对应值</span>

       <span class="hljs-keyword">function</span> get<span class="hljs-constructor">AndRemoveAttr(<span class="hljs-params">el</span>, <span class="hljs-params">name</span>)</span> {
           <span class="hljs-keyword">let</span> <span class="hljs-keyword">val</span>;
           <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">val</span> = el.attrsMap<span class="hljs-literal">[<span class="hljs-identifier">name</span>]</span>) != null) {
               const <span class="hljs-built_in">list</span> = el.attrsList;
               for (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = <span class="hljs-built_in">list</span>.length; i &lt; l; i++) {
                   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">list</span><span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.name<span class="hljs-operator"> === </span>name) {
                       <span class="hljs-built_in">list</span>.splice(i , <span class="hljs-number">1</span>);
                       break;
                   }
               }
           }
           return <span class="hljs-keyword">val</span>;
       }

       <span class="hljs-comment">// v-for 会将指令解析成for属性以及alias属性， 而v-if会将条件都存入ifConditions数组中</span>

       <span class="hljs-keyword">function</span> process<span class="hljs-constructor">For(<span class="hljs-params">e</span>)</span> {
           <span class="hljs-keyword">let</span> exp;
           <span class="hljs-keyword">if</span> ((exp = get<span class="hljs-constructor">AndRemoveAttr(<span class="hljs-params">el</span>, '<span class="hljs-params">v</span>-<span class="hljs-params">for</span>')</span>)) {
               const inMatch = exp.<span class="hljs-keyword">match</span>(forAliasRE);
               el.for = inMatch<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>.trim<span class="hljs-literal">()</span>;
               el.alias = inMatch<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>.trim<span class="hljs-literal">()</span>;
           }
       }

       <span class="hljs-keyword">function</span> process<span class="hljs-constructor">If(<span class="hljs-params">el</span>)</span> {
           const exp = get<span class="hljs-constructor">AndRemoveAttr(<span class="hljs-params">el</span>, '<span class="hljs-params">v</span>-<span class="hljs-params">if</span>')</span>;
           <span class="hljs-keyword">if</span> (exp) {
               el.<span class="hljs-keyword">if</span> = exp;
               <span class="hljs-keyword">if</span> (!el.ifConditions) {
                   el.ifConditions = <span class="hljs-literal">[]</span>;
               }
               el.ifConditions.push({
                   exp: exp,
                   block: el
               })
           }
       }
</code></pre>
<ul>
<li>optimize</li>
</ul>
<blockquote>
<p>优化。 给静态节点加上static 属性，那么在patch时bianhui9跳过这些标记的节点的比对</p>
</blockquote>
<pre><code class="hljs"><span class="hljs-comment">//optimize后的结果</span>
{
    attrsMap: {
        <span class="hljs-string">':class'</span>: <span class="hljs-string">'c'</span>,
        <span class="hljs-string">'class'</span>:<span class="hljs-string">'demo'</span>,
        <span class="hljs-string">'v-if'</span>: <span class="hljs-string">'isShow'</span>
    },
    classBinding:<span class="hljs-string">'c'</span>,
    <span class="hljs-string">'if'</span>: <span class="hljs-string">'isShow'</span>,
    ifConditions: [
        <span class="hljs-string">'exp'</span>: <span class="hljs-string">'isShow'</span>
    ],
    staticClass:<span class="hljs-string">'demo'</span>,
    <span class="hljs-string">'tag'</span>:<span class="hljs-string">'div'</span>,
    <span class="hljs-comment">//静态标志</span>
    <span class="hljs-keyword">static</span>: <span class="hljs-keyword">false</span>,
    children: [
        {
            attrsMap: {
                <span class="hljs-string">'v-for'</span>:<span class="hljs-string">"item in sz"</span>
            },
            <span class="hljs-keyword">static</span> : <span class="hljs-keyword">false</span>,
            alias: <span class="hljs-string">'item'</span>,
            <span class="hljs-keyword">for</span>: <span class="hljs-string">'sz'</span>,
            forProcessed: <span class="hljs-keyword">true</span>,
            tag: <span class="hljs-string">'span'</span>,
            children: [
                {
                    expression: <span class="hljs-string">'_s(item)'</span>,
                    text: <span class="hljs-string">'{{item}}'</span>,
                    <span class="hljs-keyword">static</span>: <span class="hljs-keyword">false</span>
                }
            ]
        }
    ]
}

<span class="hljs-comment">// isStatic</span>
<span class="hljs-comment">// 判断是否为静态节点</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStatic</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">2</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">3</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
    <span class="hljs-keyword">return</span> (!node.<span class="hljs-keyword">if</span> &amp;&amp; !node.<span class="hljs-keyword">for</span>)
}

<span class="hljs-comment">//markStatic </span>
<span class="hljs-comment">//为所有节点标记上static ，遍历所有节点通过isStatic标记</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markStatic</span> <span class="hljs-params">(node)</span> </span>{
    node.<span class="hljs-keyword">static</span> = isStatic(node);
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>, l = node.children.length; i&lt; l; i++) {
            <span class="hljs-keyword">const</span> child = node.chilren[i];
            markStatic(child);
            <span class="hljs-keyword">if</span> (!child.<span class="hljs-keyword">static</span>) {
                node.<span class="hljs-keyword">static</span> = <span class="hljs-keyword">false</span>;
            }
        }
    }
}

<span class="hljs-comment">//markStaticRoots</span>
<span class="hljs-comment">//标记staticRoot, 如果当前节点是静态节点，同时并不是只有一个文本左右子节点</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markStaticRoots</span><span class="hljs-params">(node)</span> </span>{
    <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> (node.<span class="hljs-keyword">static</span> &amp;&amp; node.children.length &amp;&amp; !(
            node.children.length === <span class="hljs-number">1</span> &amp;&amp;
            node.children[<span class="hljs-number">0</span>].type ===<span class="hljs-number">3</span>
        )) {
            node.staticRoot = <span class="hljs-keyword">true</span>;
        } <span class="hljs-keyword">else</span> {
            node.staticRoot = <span class="hljs-keyword">false</span>;
        }
    }
}

<span class="hljs-comment">//最后的optimize</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">optimize</span><span class="hljs-params">(rootAst)</span> </span>{
    markStatic(rootAst);
    markStaticRoot(rootAst);
}
</code></pre>
<ul>
<li>generate</li>
</ul>
<blockquote>
<p>将AST 转换成render function 字符串, 最终得到render字符串以及staticRenderFns字符串</p>
</blockquote>
<pre><code class="hljs">    <span class="hljs-comment">//vue.js编译后的结果</span>
    <span class="hljs-keyword">with</span>(<span class="hljs-keyword">this</span>) {
        <span class="hljs-keyword">return</span> (isShow) ? 
        _c(   <span class="hljs-comment">//createElement</span>
            <span class="hljs-string">'div'</span>,
            {
                <span class="hljs-attribute">staticClass</span>: <span class="hljs-string">'demo'</span>,
                <span class="hljs-attribute">class</span>: c
            },
            _l(
                (sz),
                <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>{
                    <span class="hljs-keyword">return</span> _c(<span class="hljs-string">'span'</span>, [_v(_s(item))])
                }
            )
        )
        : _e()
    }

    <span class="hljs-comment">//第一层div节点</span>
    render() {
        <span class="hljs-keyword">return</span> isShow ? (<span class="hljs-keyword">new</span> Vnode(<span class="hljs-string">'div'</span>, {
            <span class="hljs-string">'staticClass'</span> : <span class="hljs-string">'demo'</span>,
            <span class="hljs-attribute">class</span> : c
        }, [<span class="hljs-comment">/*子节点*/</span>])) : createEmptyNode();
    }

    <span class="hljs-comment">//在children中加上第二层span及其子文本节点</span>
    <span class="hljs-comment">// 渲染v-for列表</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderList</span>(<span class="hljs-params">val, render</span>) </span>{
        <span class="hljs-keyword">let</span> ret = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(val.length);
        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i =<span class="hljs-number">0</span>, l = val.length; i&lt; l; i++ ) {
            ret[i] = render(val[i], i);
        }
    }
    render() {
        <span class="hljs-keyword">return</span> isShow ? (<span class="hljs-keyword">new</span> VNode(<span class="hljs-string">'div'</span>, {
            <span class="hljs-string">'staticClass'</span>: <span class="hljs-string">'demo'</span>,
            <span class="hljs-attribute">class</span>: c
        },
            renderList(sz, (item) =&gt; {
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Vnode(<span class="hljs-string">'span'</span>, {}, [
                    createTextVNode()
                ])
            })
        )) : createEmptyVNode();
    }

    <span class="hljs-comment">//genIf</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genIf</span>(<span class="hljs-params">el</span>) </span>{
        el.ifProcessed = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (!el.ifConditions.length) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'_e()'</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">`(<span class="hljs-subst">${el.ifConditions[0].exp}</span>) ? <span class="hljs-subst">${genElement(el.ifConditions[0].block)}</span>: _e()`</span>
    }

    <span class="hljs-comment">//genFor </span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFor</span>(<span class="hljs-params">el</span>) </span>{
        el.forProcessed = <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">const</span> exp = el.for;
        <span class="hljs-keyword">const</span> alias = el.alias;
        <span class="hljs-keyword">const</span> interator1 = el.iterator1 ? <span class="hljs-string">`,<span class="hljs-subst">${el.iterator1}</span>`</span> : <span class="hljs-string">''</span>;
        <span class="hljs-keyword">const</span> interator2 = el.iterator2 ? <span class="hljs-string">`,<span class="hljs-subst">${el.iterator2}</span>`</span> : <span class="hljs-string">''</span>;

        <span class="hljs-keyword">return</span> <span class="hljs-string">`_l((<span class="hljs-subst">${exp}</span>)),`</span> + 
                    <span class="hljs-string">`function(<span class="hljs-subst">${alias}</span><span class="hljs-subst">${iterator1}</span><span class="hljs-subst">${iterator2}</span>)`</span> + 
                    <span class="hljs-string">`return <span class="hljs-subst">${genElement(el)}</span>`</span> +
                    <span class="hljs-string">'})'</span>
    }

    <span class="hljs-comment">//genText</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genText</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">`_v(<span class="hljs-subst">${el.expression}</span>)`</span>
    }

    <span class="hljs-comment">//genElement</span>
    <span class="hljs-comment">//处理节点的函数， 依赖于genChildren, genNode</span>
    <span class="hljs-comment">//genElement 会根据当前节点是否有if或者for标记然后判断是否要用genIf 或者genFor处理。</span>
    <span class="hljs-comment">//不然会通过genChildrenm处理子节点,同时得到staticClass, class等属性</span>
    <span class="hljs-comment">// genChildren: 遍历所有子节点， 通过genNode 处理后将"," 隔开凭借城字符串</span>
    <span class="hljs-comment">//genNode根据type来判断节点是用文本节点genText还是标签节点genElement来处理</span>

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genNode</span>(<span class="hljs-params">el</span>) </span>{
        <span class="hljs-keyword">if</span> (el.type === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> genElement(el);
        } <span class="hljs-title">else</span> {
            <span class="hljs-keyword">return</span> genText(el);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genChildren</span>(<span class="hljs-params">el</span>) </span>{
        <span class="hljs-keyword">const</span> children = el.children;
        <span class="hljs-keyword">if</span> (children &amp;&amp; chilren.length &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">${children.map(genNode).join(',')}</span>`</span>;
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genElement</span>(<span class="hljs-params">el</span>) </span>{
        <span class="hljs-keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) {
            <span class="hljs-keyword">return</span> genIf(el);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.for &amp;&amp; !el.forProcessed) {
            <span class="hljs-keyword">return</span> genFor(el);
        } <span class="hljs-title">else</span> {
            <span class="hljs-keyword">const</span> children = genChildren(el);
            <span class="hljs-keyword">let</span> code;
            code = <span class="hljs-string">`_c('<span class="hljs-subst">${el.tag}</span>,'{
                staticClass: <span class="hljs-subst">${el.attrsMap &amp;&amp; el.attrsMap[':calss']}</span>,
                class: <span class="hljs-subst">${el.attrsMap &amp;&amp; el.attrsMap['class]}</span>,
            }<span class="hljs-subst">${
                children ? `,${children}</span>`</span> : <span class="hljs-string">''</span>
            }
            })<span class="hljs-string">`

            return code;
        }
    }

    //generate 
    //将整个AST传入后判断是否为空,为空则人会div标签
    function generate(rootAst) {
        const code = rootAst ? genElement(rootAst) : '_c("div")';
        return {
            render: `</span><span class="hljs-keyword">with</span>(<span class="hljs-keyword">this</span>){<span class="hljs-keyword">return</span> ${code}}<span class="hljs-string">`
        }
    }

</span></code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/vue-02"><span class="arrow-prev">← </span><span>vue剖析笔记04-实现一个VNode节点</span></a><a class="docs-next button" href="/docs/vue-04"><span>vue剖析笔记02-响应式系统</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#compile">compile</a></li><li><a href="#parse">parse</a></li></ul></nav></div></div></body></html>